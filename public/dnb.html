<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reverb Machine</title>
  <!-- Open Graph meta tags -->
  <meta property="og:title" content="Reverb Machine">
  <meta property="og:description" content="An interactive reverb machine where moving balls control reverb.">
  <meta property="og:image" content="assets/test/og-image.png">
  <meta name="twitter:card" content="summary_large_image">

  <!-- Load Google Web Font: Cormorant -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant&display=swap" rel="stylesheet">
  
  <!-- Load p5.js and p5.sound from local paths -->
  <script src="js/p5/p5.min.js"></script>
  <script src="js/p5/addons/p5.sound.min.js"></script>
  
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: 'Cormorant', serif;
    }
  </style>
</head>
<body>
<script>
  // Noise offsets for each ball
  var t = 0, t2 = 100, t3 = 200, t4 = 300, t5 = 400, t6 = 500;

  // ---------------- Audio Variables (6 systems) ----------------
  let dnb1, dnb2, dnb3, dnb4, dnb5, dnb6;
  let gain1, gain2, gain3, gain4, gain5, gain6;
  
  // Global master bus and effect chain (kept for overall sound processing)
  let masterBus, dryGain, wetGain;
  let heavyDelay, bandpass, distortion;
  let globalEffectMix = 0;
  let mousePressStart = 0;
  let isPlaying = false;

  // ---------------- Ball Position Variables ----------------
  let offset1, offset2, offset3, offset4, offset5, offset6;
  let finalX1, finalY1, finalX2, finalY2, finalX3, finalY3, finalX4, finalY4, finalX5, finalY5, finalX6, finalY6;
  let size1, size2, size3, size4, size5, size6;

  // System active state and fade values.
  let system1Active = false, system2Active = false, system3Active = false, system4Active = false, system5Active = false, system6Active = false;
  let system1Fade = 0, system2Fade = 0, system3Fade = 0, system4Fade = 0, system5Fade = 0, system6Fade = 0;
  let fadeRate = 0.01; // fade step per frame

  // Variables for messages
  let startMessageAlpha = 255;
  let messageActive = true;
  let firstClickTime = 0;
  let scareMessageAlpha = 0;
  let scareMessageFadingOut = false;

  function preload(){
    // Load the six dnb sounds.
    dnb1 = loadSound("assets/test/dnb1.wav");
    dnb2 = loadSound("assets/test/dnb2.wav");
    dnb3 = loadSound("assets/test/dnb3.wav");
    dnb4 = loadSound("assets/test/dnb4.wav");
    dnb5 = loadSound("assets/test/dnb5.wav");
    dnb6 = loadSound("assets/test/dnb6.wav");
  }

  function setup(){
    createCanvas(windowWidth, windowHeight);
    textFont("Cormorant");
    // Initialize offsets for each ball.
    offset1 = createVector(0,0);
    offset2 = createVector(0,0);
    offset3 = createVector(0,0);
    offset4 = createVector(0,0);
    offset5 = createVector(0,0);
    offset6 = createVector(0,0);
    
    let bg = color("#FFE4E1");
    bg.setAlpha(10);
    background(bg);
    userStartAudio().then(() => console.log("Audio Started"));
  }

  // Utility: create a distortion curve for a WaveShaper node.
  function makeDistortionCurve(amount) {
    let k = typeof amount === 'number' ? amount : 50;
    let n_samples = 44100;
    let curve = new Float32Array(n_samples);
    let deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      let x = i * 2 / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  function startAudio(){
    if(!isPlaying &&
       dnb1.isLoaded() && dnb2.isLoaded() && dnb3.isLoaded() &&
       dnb4.isLoaded() && dnb5.isLoaded() && dnb6.isLoaded()){
      let audioContext = getAudioContext();
      
      // Create gain nodes for each sound.
      gain1 = audioContext.createGain();
      gain2 = audioContext.createGain();
      gain3 = audioContext.createGain();
      gain4 = audioContext.createGain();
      gain5 = audioContext.createGain();
      gain6 = audioContext.createGain();
      
      // Start each sound in loop and route it through its gain node.
      dnb1.disconnect();
      dnb1.loop();
      dnb1.connect(gain1);
      
      dnb2.disconnect();
      dnb2.loop();
      dnb2.connect(gain2);
      
      dnb3.disconnect();
      dnb3.loop();
      dnb3.connect(gain3);
      
      dnb4.disconnect();
      dnb4.loop();
      dnb4.connect(gain4);
      
      dnb5.disconnect();
      dnb5.loop();
      dnb5.connect(gain5);
      
      dnb6.disconnect();
      dnb6.loop();
      dnb6.connect(gain6);
      
      // ---------------- Set Up Global Master Bus & Effects ----------------
      masterBus = audioContext.createGain();
      // Route each gain node to the master bus.
      gain1.connect(masterBus);
      gain2.connect(masterBus);
      gain3.connect(masterBus);
      gain4.connect(masterBus);
      gain5.connect(masterBus);
      gain6.connect(masterBus);
      
      // Create dry and wet paths.
      dryGain = audioContext.createGain();
      wetGain = audioContext.createGain();
      masterBus.connect(dryGain);
      masterBus.connect(wetGain);
      dryGain.gain.value = 1;
      wetGain.gain.value = 0;
      
      // Global effect chain: heavy delay -> bandpass -> distortion.
      heavyDelay = audioContext.createDelay();
      heavyDelay.delayTime.value = 1.0;
      bandpass = audioContext.createBiquadFilter();
      bandpass.type = "bandpass";
      bandpass.frequency.value = 1000;
      bandpass.Q.value = 5;
      distortion = audioContext.createWaveShaper();
      distortion.curve = makeDistortionCurve(50);
      distortion.oversample = "4x";
      
      wetGain.connect(heavyDelay);
      heavyDelay.connect(bandpass);
      bandpass.connect(distortion);
      distortion.connect(audioContext.destination);
      dryGain.connect(audioContext.destination);
      
      isPlaying = true;
    }
  }

  function draw(){
    let bg = color("#FFE4E1");
    bg.setAlpha(10);
    background(bg);

    // ---------------- Global Effect Mix Control ----------------
    if(mouseIsPressed && mousePressStart && (millis() - mousePressStart >= 500)){
      globalEffectMix = min(globalEffectMix + fadeRate, 1);
    } else {
      globalEffectMix = max(globalEffectMix - fadeRate, 0);
    }
    if(isPlaying && dryGain && wetGain){
      dryGain.gain.value = 1 - globalEffectMix;
      wetGain.gain.value = globalEffectMix;
    }

    // ---------------- Compute Base Positions from Noise ----------------
    let baseX1 = width * noise(t);
    let baseY1 = height * noise(t + 5);
    let baseX2 = width * noise(t2);
    let baseY2 = height * noise(t2 + 5);
    let baseX3 = width * noise(t3);
    let baseY3 = height * noise(t3 + 5);
    let baseX4 = width * noise(t4);
    let baseY4 = height * noise(t4 + 5);
    let baseX5 = width * noise(t5);
    let baseY5 = height * noise(t5 + 5);
    let baseX6 = width * noise(t6);
    let baseY6 = height * noise(t6 + 5);

    // ---------------- Update Offsets for Repulsion ----------------
    if(mouseIsPressed){
      let mousePos = createVector(mouseX, mouseY);
      let pos1 = createVector(baseX1, baseY1).add(offset1);
      let diff1 = p5.Vector.sub(pos1, mousePos);
      if(diff1.mag() > 0){ diff1.normalize().mult(3); offset1.add(diff1); }
      let pos2 = createVector(baseX2, baseY2).add(offset2);
      let diff2 = p5.Vector.sub(pos2, mousePos);
      if(diff2.mag() > 0){ diff2.normalize().mult(3); offset2.add(diff2); }
      let pos3 = createVector(baseX3, baseY3).add(offset3);
      let diff3 = p5.Vector.sub(pos3, mousePos);
      if(diff3.mag() > 0){ diff3.normalize().mult(3); offset3.add(diff3); }
      let pos4 = createVector(baseX4, baseY4).add(offset4);
      let diff4 = p5.Vector.sub(pos4, mousePos);
      if(diff4.mag() > 0){ diff4.normalize().mult(3); offset4.add(diff4); }
      let pos5 = createVector(baseX5, baseY5).add(offset5);
      let diff5 = p5.Vector.sub(pos5, mousePos);
      if(diff5.mag() > 0){ diff5.normalize().mult(3); offset5.add(diff5); }
      let pos6 = createVector(baseX6, baseY6).add(offset6);
      let diff6 = p5.Vector.sub(pos6, mousePos);
      if(diff6.mag() > 0){ diff6.normalize().mult(3); offset6.add(diff6); }
    } else {
      offset1.mult(0.95);
      offset2.mult(0.95);
      offset3.mult(0.95);
      offset4.mult(0.95);
      offset5.mult(0.95);
      offset6.mult(0.95);
    }

    // ---------------- Compute Final Positions ----------------
    finalX1 = baseX1 + offset1.x;
    finalY1 = baseY1 + offset1.y;
    finalX2 = baseX2 + offset2.x;
    finalY2 = baseY2 + offset2.y;
    finalX3 = baseX3 + offset3.x;
    finalY3 = baseY3 + offset3.y;
    finalX4 = baseX4 + offset4.x;
    finalY4 = baseY4 + offset4.y;
    finalX5 = baseX5 + offset5.x;
    finalY5 = baseY5 + offset5.y;
    finalX6 = baseX6 + offset6.x;
    finalY6 = baseY6 + offset6.y;

    // ---------------- Determine Sizes ----------------
    size1 = map(finalX1, 0, width, 50, 200);
    size2 = map(finalY2, 0, height, 50, 200);
    size3 = map(finalX3, 0, width, 50, 200);
    size4 = map(finalY4, 0, height, 50, 200);
    size5 = map(finalX5, 0, width, 50, 200);
    size6 = map(finalY6, 0, height, 50, 200);

    // Constrain positions so balls remain within the canvas
    finalX1 = constrain(finalX1, size1/2, width - size1/2);
    finalY1 = constrain(finalY1, size1/2, height - size1/2);
    finalX2 = constrain(finalX2, size2/2, width - size2/2);
    finalY2 = constrain(finalY2, size2/2, height - size2/2);
    finalX3 = constrain(finalX3, size3/2, width - size3/2);
    finalY3 = constrain(finalY3, size3/2, height - size3/2);
    finalX4 = constrain(finalX4, size4/2, width - size4/2);
    finalY4 = constrain(finalY4, size4/2, height - size4/2);
    finalX5 = constrain(finalX5, size5/2, width - size5/2);
    finalY5 = constrain(finalY5, size5/2, height - size5/2);
    finalX6 = constrain(finalX6, size6/2, width - size6/2);
    finalY6 = constrain(finalY6, size6/2, height - size6/2);

    noStroke();
    // ---------------- Draw System 1 Ball (horizontal control) ----------------
    let r1 = 255 * noise(t + 10);
    let g1 = 255 * noise(t + 15);
    let b1 = 255 * noise(t + 20);
    let grey1 = (r1 + g1 + b1) / 3;
    let finalR1 = lerp(grey1, r1, system1Fade);
    let finalG1 = lerp(grey1, g1, system1Fade);
    let finalB1 = lerp(grey1, b1, system1Fade);
    fill(finalR1, finalG1, finalB1, 150);
    ellipse(finalX1, finalY1, size1, size1);

    // ---------------- Draw System 2 Ball (vertical control) ----------------
    let r2 = 255 * noise(t2 + 10);
    let g2 = 255 * noise(t2 + 15);
    let b2 = 255 * noise(t2 + 20);
    let grey2 = (r2 + g2 + b2) / 3;
    let finalR2 = lerp(grey2, r2, system2Fade);
    let finalG2 = lerp(grey2, g2, system2Fade);
    let finalB2 = lerp(grey2, b2, system2Fade);
    fill(finalR2, finalG2, finalB2, 150);
    ellipse(finalX2, finalY2, size2, size2);

    // ---------------- Draw System 3 Ball (horizontal control) ----------------
    let r3 = 255 * noise(t3 + 10);
    let g3 = 255 * noise(t3 + 15);
    let b3 = 255 * noise(t3 + 20);
    let grey3 = (r3 + g3 + b3) / 3;
    let finalR3 = lerp(grey3, r3, system3Fade);
    let finalG3 = lerp(grey3, g3, system3Fade);
    let finalB3 = lerp(grey3, b3, system3Fade);
    fill(finalR3, finalG3, finalB3, 150);
    ellipse(finalX3, finalY3, size3, size3);

    // ---------------- Draw System 4 Ball (vertical control) ----------------
    let r4 = 255 * noise(t4 + 10);
    let g4 = 255 * noise(t4 + 15);
    let b4 = 255 * noise(t4 + 20);
    let grey4 = (r4 + g4 + b4) / 3;
    let finalR4 = lerp(grey4, r4, system4Fade);
    let finalG4 = lerp(grey4, g4, system4Fade);
    let finalB4 = lerp(grey4, b4, system4Fade);
    fill(finalR4, finalG4, finalB4, 150);
    ellipse(finalX4, finalY4, size4, size4);

    // ---------------- Draw System 5 Ball (horizontal control) ----------------
    let r5 = 255 * noise(t5 + 10);
    let g5 = 255 * noise(t5 + 15);
    let b5 = 255 * noise(t5 + 20);
    let grey5 = (r5 + g5 + b5) / 3;
    let finalR5 = lerp(grey5, r5, system5Fade);
    let finalG5 = lerp(grey5, g5, system5Fade);
    let finalB5 = lerp(grey5, b5, system5Fade);
    fill(finalR5, finalG5, finalB5, 150);
    ellipse(finalX5, finalY5, size5, size5);

    // ---------------- Draw System 6 Ball (vertical control) ----------------
    let r6 = 255 * noise(t6 + 10);
    let g6 = 255 * noise(t6 + 15);
    let b6 = 255 * noise(t6 + 20);
    let grey6 = (r6 + g6 + b6) / 3;
    let finalR6 = lerp(grey6, r6, system6Fade);
    let finalG6 = lerp(grey6, g6, system6Fade);
    let finalB6 = lerp(grey6, b6, system6Fade);
    fill(finalR6, finalG6, finalB6, 150);
    ellipse(finalX6, finalY6, size6, size6);

    // ---------------- Map Volume Based on Final Position ----------------
    let vol1 = map(finalX1, 0, width, 0, 0.15);
    let vol2 = map(finalY2, 0, height, 0, 0.15);
    let vol3 = map(finalX3, 0, width, 0, 0.15);
    let vol4 = map(finalY4, 0, height, 0, 0.15);
    let vol5 = map(finalX5, 0, width, 0, 0.15);
    let vol6 = map(finalY6, 0, height, 0, 0.15);

    // ---------------- Update Fade Values ----------------
    system1Fade = system1Active ? min(system1Fade + fadeRate, 1) : max(system1Fade - fadeRate, 0);
    system2Fade = system2Active ? min(system2Fade + fadeRate, 1) : max(system2Fade - fadeRate, 0);
    system3Fade = system3Active ? min(system3Fade + fadeRate, 1) : max(system3Fade - fadeRate, 0);
    system4Fade = system4Active ? min(system4Fade + fadeRate, 1) : max(system4Fade - fadeRate, 0);
    system5Fade = system5Active ? min(system5Fade + fadeRate, 1) : max(system5Fade - fadeRate, 0);
    system6Fade = system6Active ? min(system6Fade + fadeRate, 1) : max(system6Fade - fadeRate, 0);

    // ---------------- Update Audio Gains ----------------
    if(isPlaying && gain1 && gain2 && gain3 && gain4 && gain5 && gain6){
      gain1.gain.value = vol1 * system1Fade;
      gain2.gain.value = vol2 * system2Fade;
      gain3.gain.value = vol3 * system3Fade;
      gain4.gain.value = vol4 * system4Fade;
      gain5.gain.value = vol5 * system5Fade;
      gain6.gain.value = vol6 * system6Fade;
    }

    // Increment noise offsets for smooth movement
    t += 0.002;
    t2 += 0.003;
    t3 += 0.0025;
    t4 += 0.0035;
    t5 += 0.0027;
    t6 += 0.0032;

    // ---------------- Display "click a ball to continue" Message ----------------
    if(startMessageAlpha > 0){
      let msgColor = color("#ccad9e");
      msgColor.setAlpha(startMessageAlpha);
      fill(msgColor);
      textSize(32);
      textAlign(CENTER, CENTER);
      text("click a ball to continue", width/2, height/2);
      if(!messageActive){
        startMessageAlpha -= 5;
      }
    }
    
    // ---------------- Display "Click and hold to scare the balls" Message ----------------
    if(firstClickTime > 0 && millis() - firstClickTime >= 15000){
      if(!scareMessageFadingOut){
        scareMessageAlpha = min(scareMessageAlpha + 5, 255);
      } else {
        scareMessageAlpha = max(scareMessageAlpha - 5, 0);
      }
      let scareMsgColor = color("#ccad9e");
      scareMsgColor.setAlpha(scareMessageAlpha);
      fill(scareMsgColor);
      textSize(32);
      textAlign(CENTER, CENTER);
      text("Click and hold to scare the balls", width/2, height * 0.8);
    }
  }

  function mousePressed(){
    startAudio();
    if(messageActive){
      messageActive = false;
      if(firstClickTime === 0){
        firstClickTime = millis();
      }
    }
    if(scareMessageAlpha > 0){
      scareMessageFadingOut = true;
    }
    if(mousePressStart === 0){
      mousePressStart = millis();
    }
    if(dist(mouseX, mouseY, finalX1, finalY1) < size1/2){
      system1Active = !system1Active;
    }
    if(dist(mouseX, mouseY, finalX2, finalY2) < size2/2){
      system2Active = !system2Active;
    }
    if(dist(mouseX, mouseY, finalX3, finalY3) < size3/2){
      system3Active = !system3Active;
    }
    if(dist(mouseX, mouseY, finalX4, finalY4) < size4/2){
      system4Active = !system4Active;
    }
    if(dist(mouseX, mouseY, finalX5, finalY5) < size5/2){
      system5Active = !system5Active;
    }
    if(dist(mouseX, mouseY, finalX6, finalY6) < size6/2){
      system6Active = !system6Active;
    }
  }

  function mouseReleased(){
    mousePressStart = 0;
  }

  // Mobile interaction: map touch events to mouse events.
  function touchStarted(){
    mousePressed();
    return false;
  }
  
  function touchEnded(){
    mouseReleased();
    return false;
  }

  function windowResized(){
    resizeCanvas(windowWidth, windowHeight);
  }
</script>
</body>
</html>
