<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Thread Simulation with Mobile Tap</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: black; }
        canvas { display: block; background: black; }
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            font-size: 48px;
            cursor: pointer;
            z-index: 10;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="startScreen">Click to Continue</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');

        // Constants
        const GRAVITY = 0.3;
        const DAMPING = 0.98;
        const SEGMENT_LENGTH = 10;
        const NUM_THREADS = 40;
        const MOUSE_RADIUS = 100;
        const MOUSE_FORCE = 1.5;

        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const C_PENTATONIC_MINOR_BASE = [16.35, 19.45, 21.83, 24.50, 29.14]; // C0, Eb0, F0, G0, Bb0
        const NOTES = [];
        for (let octave = 0; octave < 8; octave++) {
            C_PENTATONIC_MINOR_BASE.forEach(note => {
                NOTES.push(note * Math.pow(2, octave));
            });
        }

        // Colors for C, Eb, F, G, Bb
        const COLORS = ['#4a3b6e', '#5e548e', '#9f86c0', '#be95c4', '#e0b1cb'];

        // Reverb
        const reverb = audioCtx.createConvolver();
        function createImpulseResponse() {
            const length = audioCtx.sampleRate * 1.0;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const n = length - i;
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
            reverb.buffer = impulse;
        }
        createImpulseResponse();

        // Interaction position (shared for mouse and touch)
        let pointer = { x: 0, y: 0, prevX: 0, prevY: 0, active: false };
        let started = false;

        // Particle class
        class Particle {
            constructor(x, y, pinned = false) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.pinned = pinned;
            }

            update() {
                if (this.pinned) return;
                let vx = (this.x - this.oldX) * DAMPING;
                let vy = (this.y - this.oldY) * DAMPING;

                if (pointer.active) {
                    const dx = this.x - pointer.x;
                    const dy = this.y - pointer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < MOUSE_RADIUS && distance > 0) {
                        const force = MOUSE_FORCE * (1 - distance / MOUSE_RADIUS);
                        vx += (dx / distance) * force;
                        vy += (dy / distance) * force;
                    }
                }

                this.oldX = this.x;
                this.oldY = this.y;
                this.x += vx;
                this.y += vy + GRAVITY;
            }
        }

        // Initialize or resize threads
        let threads = [];
        function initThreads() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const PARTICLES_PER_THREAD = Math.ceil(canvas.height / SEGMENT_LENGTH);
            threads = [];
            for (let i = 0; i < NUM_THREADS; i++) {
                const thread = [];
                const startX = (canvas.width / NUM_THREADS) * i + (canvas.width / NUM_THREADS) / 2;
                for (let j = 0; j < PARTICLES_PER_THREAD; j++) {
                    const y = j * SEGMENT_LENGTH;
                    thread.push(new Particle(startX, y, j === 0));
                }
                threads.push(thread);
            }
        }

        // Constraint function
        function applyConstraints(thread) {
            for (let i = 0; i < thread.length - 1; i++) {
                const p1 = thread[i];
                const p2 = thread[i + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = SEGMENT_LENGTH - distance;
                const percent = (difference / distance) / 2;
                const offsetX = dx * percent;
                const offsetY = dy * percent;

                if (!p1.pinned) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                if (!p2.pinned) {
                    p2.x += offsetX;
                    p2.y += offsetY;
                }
            }
        }

        // Play a note with pitch-adjusted volume
        function playNote(frequency) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(reverb);
            reverb.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.value = frequency;

            const maxVolume = 1.0;
            const minVolume = 0.05;
            const logVolume = maxVolume * Math.pow(0.2, Math.log2(frequency / NOTES[0]));
            const volume = Math.max(minVolume, Math.min(maxVolume, logVolume));

            const now = audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.3);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.6);

            oscillator.start(now);
            oscillator.stop(now + 0.6);
        }

        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            if (!started) return;
            const rect = canvas.getBoundingClientRect();
            pointer.prevX = pointer.x;
            pointer.prevY = pointer.y;
            pointer.x = e.clientX - rect.left;
            pointer.y = e.clientY - rect.top;
            pointer.active = true;

            threads.forEach((thread, index) => {
                const threadX = thread[0].x;
                if ((pointer.prevX < threadX && pointer.x >= threadX) || (pointer.prevX > threadX && pointer.x <= threadX)) {
                    playNote(NOTES[index]);
                }
            });
        });

        canvas.addEventListener('mouseleave', () => {
            pointer.active = false;
        });

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!started) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pointer.x = touch.clientX - rect.left;
            pointer.y = touch.clientY - rect.top;
            pointer.active = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!started) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pointer.prevX = pointer.x;
            pointer.prevY = pointer.y;
            pointer.x = touch.clientX - rect.left;
            pointer.y = touch.clientY - rect.top;
            pointer.active = true;

            threads.forEach((thread, index) => {
                const threadX = thread[0].x;
                if ((pointer.prevX < threadX && pointer.x >= threadX) || (pointer.prevX > threadX && pointer.x <= threadX)) {
                    playNote(NOTES[index]);
                }
            });
        });

        canvas.addEventListener('touchend', () => {
            pointer.active = false;
        });

        // Resize handler
        window.addEventListener('resize', () => {
            initThreads();
        });

        // Start screen handler with fade-out
        startScreen.addEventListener('click', () => {
            started = true;
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
                initThreads();
                animate();
            }, 500);
        });

        // Simulation loop
        function animate() {
            if (!started) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            threads.forEach((thread, index) => {
                thread.forEach(particle => particle.update());
                for (let i = 0; i < 3; i++) {
                    applyConstraints(thread);
                }

                let minDistance = Infinity;
                thread.forEach(p => {
                    const dx = p.x - pointer.x;
                    const dy = p.y - pointer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) minDistance = distance;
                });
                const brightness = Math.max(50, 255 * (1 - Math.min(minDistance / MOUSE_RADIUS, 1)));

                const baseColor = COLORS[index % 5];
                const [r, g, b] = [
                    parseInt(baseColor.slice(1, 3), 16),
                    parseInt(baseColor.slice(3, 5), 16),
                    parseInt(baseColor.slice(5, 7), 16)
                ];
                const color = `rgb(${(r * brightness) / 255}, ${(g * brightness) / 255}, ${(b * brightness) / 255})`;

                ctx.beginPath();
                ctx.moveTo(thread[0].x, thread[0].y);
                for (let i = 1; i < thread.length; i++) {
                    ctx.lineTo(thread[i].x, thread[i].y);
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            requestAnimationFrame(animate);
        }

        // Initial canvas setup
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    </script>
</body>
</html>